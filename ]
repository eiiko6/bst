#![allow(dead_code)]

use std::fmt::Display;

pub struct BST<T> {
    left: Option<Box<BST<T>>>,
    root: Option<T>,
    right: Option<Box<BST<T>>>,
}

impl<T> Default for BST<T> {
    fn default() -> Self {
        BST {
            left: None,
            root: None,
            right: None,
        }
    }
}

impl<T: Display> BST<T> {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn is_empty(&self) -> bool {
        self.root.is_none()
    }

    pub fn clear(&mut self) {
        self.root = None;
    }

    fn left(&mut self) -> Option<&mut Self> {
        self.left.as_deref_mut()
    }

    fn right(&mut self) -> Option<&mut Self> {
        self.right.as_deref_mut()
    }

    pub fn count_nodes(&self) -> usize {
        // if self.is_empty() {
        //     return 0;
        // }

        let left_count = match &self.left {
            Some(node) => node.count_nodes(),
            None => 0,
        };
        let right_count = match &self.right {
            Some(node) => node.count_nodes(),
            None => 0,
        };
        1 + left_count + right_count
    }

    pub fn depth(&self) -> usize {
        // if self.is_empty() {
        //     return 0;
        // }

        let left_depth = match &self.left {
            Some(node) => node.depth(),
            None => 0,
        };
        let right_depth = match &self.right {
            Some(node) => node.depth(),
            None => 0,
        };

        1 + left_depth.max(right_depth)
    }

    pub fn insert_unbalanced(&mut self, val: T) -> &mut Self
    where
        T: PartialEq + PartialOrd,
    {
        if let Some(node) = &self.root {
            if *node == val {
                return self;
            }
            if val < *node {
                if let Some(left_node) = self.left.as_deref_mut() {
                    left_node.insert_unbalanced(val);
                } else {
                    self.left = Some(Box::new(BST {
                        left: None,
                        root: Some(val),
                        right: None,
                    }))
                }
                return self;
            } else {
                if let Some(right_node) = self.right.as_deref_mut() {
                    right_node.insert_unbalanced(val);
                } else {
                    self.right = Some(Box::new(BST {
                        left: None,
                        root: Some(val),
                        right: None,
                    }))
                }
                return self;
            }
        } else {
            self.root = Some(val);
            return self;
        }
    }

    pub fn display(&self, size: usize) {
        // if self.is_empty() {
        //     return;
        // }

        if let Some(tree) = &self.right {
            tree.display(size + 1);
        }

        for _ in 0..size {
            print!("---");
        }

        if let Some(node) = &self.root {
            println!("{}", node);
        }

        if let Some(tree) = &self.left {
            tree.display(size + 1);
        }
    }

    pub fn find(&self, val: T) -> Option<&Self>
    where
        T: PartialEq + PartialOrd,
    {
        match &self.root {
            None => None,
            Some(node) if *node == val => Some(self),
            Some(node) if val < *node => self.left.as_deref()?.find(val),
            Some(_) => self.right.as_deref()?.find(val),
        }
    }

    pub fn contains(&self, val: T) -> bool
    where
        T: PartialEq + PartialOrd,
    {
        self.find(val).is_some()
    }

    fn left_end(&self) -> Option<&Self> {
        if self.left.is_none() {
            match &self.left {
                None => Some(self),
                Some(node) => Some(&node),
            }
        } else {
            match &self.left {
                None => Some(self),
                Some(node) => node.left_end(),
            }
        }
    }

    fn right_end(&self) -> Option<&Self> {
        if self.right.is_none() {
            match &self.right {
                None => Some(self),
                Some(node) => Some(&node),
            }
        } else {
            match &self.right {
                None => Some(self),
                Some(node) => node.right_end(),
            }
        }
    }
}

impl Clone for BST<T> {
    fn clone(&self) -> Self {}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unbalanced_insertion() {
        let mut tree = BST::new();
        tree.insert_unbalanced(5);
        tree.insert_unbalanced(8);
        tree.insert_unbalanced(3);
        tree.insert_unbalanced(2);
        tree.insert_unbalanced(6);
        tree.insert_unbalanced(9);
        tree.insert_unbalanced(10);
        tree.insert_unbalanced(9);
        tree.display(tree.depth());

        assert_eq!(tree.count_nodes(), 7);
        assert_eq!(tree.depth(), 4);
    }

    #[test]
    fn test_find() {
        let mut tree = BST::new();
        tree.insert_unbalanced(5);
        tree.insert_unbalanced(8);
        tree.insert_unbalanced(3);
        tree.insert_unbalanced(2);
        tree.insert_unbalanced(9);
        tree.insert_unbalanced(7);

        assert!(tree.contains(2));
        assert_eq!(tree.find(2).unwrap().root.unwrap(), 2);
        assert_eq!(tree.find(7).unwrap().root.unwrap(), 7);
        assert_eq!(tree.find(5).unwrap().root.unwrap(), 5);
        assert!(tree.find(999).is_none());
    }

    #[test]
    fn test_ends() {
        let mut tree = BST::new();
        tree.insert_unbalanced(5);
        tree.insert_unbalanced(8);
        tree.insert_unbalanced(3);
        tree.insert_unbalanced(2);
        tree.insert_unbalanced(9);
        tree.insert_unbalanced(7);

        tree.display(tree.depth());

        assert_eq!(tree.left_end().unwrap().root.unwrap(), 2);
        assert_eq!(tree.right_end().unwrap().root.unwrap(), 9);
    }
}
